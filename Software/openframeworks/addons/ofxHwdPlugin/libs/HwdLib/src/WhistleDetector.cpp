/// \file
/// \brief WhistleDetector class
/// \author Alexander Konin
/// \date 08.Oct.2014

#include "WhistleDetector.h"
#include "Global.h"
#include <numeric>
#include <math.h>
#include <assert.h>

namespace Akon {
namespace HwdLib {

/*!
	\class WhistleDetector
	\brief Detects separate whistles in a signal
*/

// WhistleDetector

WhistleDetector::WhistleDetector(int binsPerWhistleRange) :
	binsPerWhistleRange_(binsPerWhistleRange),
	powerThresholdPercent_(90),
	stepsPerWhistleDuration_(6),
	binsPerFrequencyDeviation_(std::min(3, binsPerWhistleRange)),
	bins_(),
	certainties_()
{
}

void WhistleDetector::setPowerThresholdPercent(int value)
{
	if (value < 0)
		value = 0;
	if (value > 100)
		value = 100;
	if (powerThresholdPercent_ == value) return;
	powerThresholdPercent_ = value;
	//Q_EMIT powerThresholdPercentChanged(powerThresholdPercent_);
}

void WhistleDetector::setStepsPerWhistleDuration(int value)
{
	value = std::max(1, value);
	if (stepsPerWhistleDuration_ == value) return;
	stepsPerWhistleDuration_ = value;
	//Q_EMIT stepsPerWhistleDurationChanged(stepsPerWhistleDuration_);
}

void WhistleDetector::setBinsPerFrequencyDeviation(int value)
{
	if (value < 0)
		value = 0;
	if (value > binsPerWhistleRange_)
		value = binsPerWhistleRange_;
	if (binsPerFrequencyDeviation_ == value) return;
	binsPerFrequencyDeviation_ = value;
	//Q_EMIT binsPerFrequencyDeviationChanged(binsPerFrequencyDeviation_);
}

/*src:
/// ? Process one value (bin index, bin power ratio). Returns whistle average bin index or VoidBin if
/// no whistles are detected currently. A whistle detection event is generated by end front of the
/// signal. Whistle frequency (bin) is calculated as average value.
/// \param bin - STFT bin index, allowed range [0, binsPerWhistleRange());
/// \param binPowerRatio - bin energetic characteristic;
/// \param whistleCertainty - output, whistle certainty.
double WhistleDetector::operator()(double bin, double binPowerRatio, double& whistleCertainty,
	int& processingStepsPerWhistleDuration)
{
	// Params may change from other (user) thread, check that they change with atomic instruction
	// (mov/add m32/m64), i.e. they have size <= sizeof(void*)
	static_assert(sizeof(powerThresholdPercent_) <= sizeof(void*), "");
	static_assert(sizeof(stepsPerWhistleDuration_) <= sizeof(void*), "");
	static_assert(sizeof(binsPerFrequencyDeviation_) <= sizeof(void*), "");

	// Use latched values due to original values may change from other (user) thread
	const int latchedPowerThresholdPercent = powerThresholdPercent_;
	const int latchedStepsPerWhistleDuration = stepsPerWhistleDuration_;
	const int latchedBinsPerFrequencyDeviation = binsPerFrequencyDeviation_;

	whistleCertainty = VoidRatio;
	processingStepsPerWhistleDuration = 0;
	double result = VoidBin;

	// Mark unsufficient on power input as void
	static const double PowerRatio = 75.0 / 90.0;
	if (binPowerRatio < latchedPowerThresholdPercent / 100.0 * PowerRatio)
		bin = VoidBin;

	// Real bin within the bounds: add it to the list
	if ((VoidBin != bin)
		&& (bins_.empty() || fabs(bin - bins_.back()) <= latchedBinsPerFrequencyDeviation)) {
		bins_.push_back(bin);
		certainties_.push_back(binPowerRatio);
	}
	// Void or unsufficient power bin, or real bin with significantly different frequency
	else {
		// There are enough consequitive bins to be treated as a whistle
		if (int(bins_.size()) >= latchedStepsPerWhistleDuration) {
			const double averagePower = std::accumulate(certainties_.cbegin(), certainties_.cend(),
				0.0) / certainties_.size();
			if (averagePower >= latchedPowerThresholdPercent / 100.0) {
				whistleCertainty = averagePower;
				processingStepsPerWhistleDuration = bins_.size();
				result = std::accumulate(bins_.cbegin(), bins_.cend(), 0) / bins_.size();
			}
		}

		bins_.clear();
		certainties_.clear();
		if (VoidBin != bin) {
			bins_.push_back(bin);
			certainties_.push_back(binPowerRatio);
		}
	}

	return result;
}
*/
/*new:*/
/// ? Process one value (bin index, bin power ratio). Returns whistle average bin index or VoidBin if
/// no whistles are detected currently. A whistle detection event is generated by end front of the
/// signal. Whistle frequency (bin) is calculated as average value.
/// \param bin - STFT bin index, allowed range [0, binsPerWhistleRange());
/// \param binPowerRatio - bin energetic characteristic;
/// \param whistleCertainty - output, whistle certainty.
double WhistleDetector::operator()(double bin, double binPowerRatio, double& whistleCertainty,
	int& processingStepsPerWhistleDuration)
{
	// Params may change from other (user) thread, check that they change with atomic instruction
	// (mov/add m32/m64), i.e. they have size <= sizeof(void*)
	static_assert(sizeof(powerThresholdPercent_) <= sizeof(void*), "");
	static_assert(sizeof(stepsPerWhistleDuration_) <= sizeof(void*), "");
	static_assert(sizeof(binsPerFrequencyDeviation_) <= sizeof(void*), "");

	// Use latched values due to original values may change from other (user) thread
	const int latchedPowerThresholdPercent = powerThresholdPercent_;
	const int latchedStepsPerWhistleDuration = stepsPerWhistleDuration_;
	const int latchedBinsPerFrequencyDeviation = binsPerFrequencyDeviation_;

	whistleCertainty = VoidRatio;
	processingStepsPerWhistleDuration = 0;
	double result = VoidBin;

	static const double ThresholdRatio = 0.7;//75.0 / 90.0;  // 70/90 = 0.8(3)
	const double enterThreshold = latchedPowerThresholdPercent / 100.0;
	const double leaveThreshold = enterThreshold * ThresholdRatio;

	// Mark unsufficient on power input as void
	if (binPowerRatio < leaveThreshold)
		bin = VoidBin;

	// Add bin if required
	if (VoidBin != bin && ((bins_.empty() && enterThreshold <= binPowerRatio) ||
		(!bins_.empty() && fabs(bin - bins_.back()) <= latchedBinsPerFrequencyDeviation &&
		enterThreshold <= getAverageValueWith(certainties_, binPowerRatio)))) {
		bins_.push_back(bin);
		certainties_.push_back(binPowerRatio);
	}

	// Stop collecting if required
	if (VoidBin == bin || (!bins_.empty() &&
		(!(fabs(bin - bins_.back()) <= latchedBinsPerFrequencyDeviation) ||
		!(enterThreshold <= getAverageValueWith(certainties_, binPowerRatio))))) {

		// There are enough consequitive bins to be treated as a whistle
		if (int(bins_.size()) >= latchedStepsPerWhistleDuration) {
			whistleCertainty = std::accumulate(certainties_.cbegin(), certainties_.cend(), 0.0) /
				certainties_.size();
			assert(enterThreshold <= whistleCertainty);
			processingStepsPerWhistleDuration = int(bins_.size());
			result = std::accumulate(bins_.cbegin(), bins_.cend(), 0.0) / bins_.size();
		}

		// Clear and add current bin if required
		bins_.clear();
		certainties_.clear();
		if (VoidBin != bin && enterThreshold <= binPowerRatio) {
			bins_.push_back(bin);
			certainties_.push_back(binPowerRatio);
		}
	}

	return result;
}
/**/
double WhistleDetector::getAverageValueWith(const std::deque<double>& list, double value)
{
	return std::accumulate(list.cbegin(), list.cend(), value) / (list.size() + 1);
}

}  // HwdLib::
}  // Akon::


/* ==TRASH==
*/
